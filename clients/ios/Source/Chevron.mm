// Copyright 2013 Viewfinder. All rights reserved.
// Author: Peter Mattis.

#import <re2/re2.h>
#import "Chevron.h"
#import "Logging.h"
#import "ScopedRef.h"
#import "Vector.h"

namespace {

// Basic SVG path parser. Only handles a subset of the SVG path commands.
//   'M' - Absolute move to
//   'm' - Relative move to
//   'L' - Absolute line to
//   'l' - Relative line to
//   'H' - Absolute horizontal line to
//   'h' - Relative horizontal line to
//   'V' - Absolute vertical line to
//   'v' - Relative vertical line to
//   'C' - Absolute cubic to
//   'c' - Relative cubic to
//
// Unsupported SVG path commands:
//   'Z', 'z', 'S', 's', 'Q', 'q', 'T', 't', 'A', 'a'
class SvgPathParser {
 public:
  SvgPathParser()
      : kFloatRE("([-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)"),
        kPathSkipRE("[ \t\r\n,]*"),
        kPathCommandRE("([MmZzLlHhVvCcSsQqTtAa])?") {
  }

  CGMutablePathRef ParsePath(Slice input, const CGAffineTransform& t) {
    ScopedRef<CGMutablePathRef> path(CGPathCreateMutable());
    Vector2f current(0, 0);
    while (!input.empty()) {
        RE2::Consume(&input, kPathSkipRE);
        if (input.empty()) {
          break;
        }
        char command = 0;
        RE2::Consume(&input, kPathCommandRE, &command);
        if (!command) {
          LOG("path-data parse error: %s", input.as_string().c_str());
          break;
        }
        switch (command) {
          case 'M':
            current = Vector2f(0, 0);
          case 'm':
            current += ParseVector2(&input);
            CGPathMoveToPoint(path, &t, current.x(), current.y());
            break;
          case 'L':
            current = Vector2f(0, 0);
          case 'l':
            current += ParseVector2(&input);
            CGPathAddLineToPoint(path, &t, current.x(), current.y());
            break;
          case 'H':
            current.x() = 0;
          case 'h':
            current.x() += ParseFloat(&input);
            CGPathAddLineToPoint(path, &t, current.x(), current.y());
            break;
          case 'V':
            current.y() = 0;
          case 'v':
            current.y() += ParseFloat(&input);
            CGPathAddLineToPoint(path, &t, current.x(), current.y());
            break;
          case 'C':
            current = Vector2f(0, 0);
          case 'c': {
            const Vector2f p1 = current + ParseVector2(&input);
            const Vector2f p2 = current + ParseVector2(&input);
            current += ParseVector2(&input);
            CGPathAddCurveToPoint(
                path, &t, p1.x(), p1.y(), p2.x(), p2.y(), current.x(), current.y());
            break;
          }
          default:
            DIE("unsupported command: %c", command);
            break;
        }
    }
    CGPathCloseSubpath(path);
    return path.release();
  }

 private:
  float ParseFloat(Slice* input) const {
    float f;
    if (!RE2::FindAndConsume(input, kFloatRE, &f)) {
      input->clear();
      return 0.0;
    }
    return f;
  }

  Vector2f ParseVector2(Slice* input) const {
    const float x = ParseFloat(input);
    const float y = ParseFloat(input);
    return Vector2f(x, y);
  }

 private:
  const RE2 kFloatRE;
  const RE2 kPathSkipRE;
  const RE2 kPathCommandRE;
};

}  // namespace

CGMutablePathRef MakeChevronPath(float size) {
  // SVG path/bounds generated by saving a single chevron of the logo from
  // Adobe Illustrator.
  const char* kSVGPath =
      "M493.918,309.812"
      "l-12.727-12.727"
      "c-2.332-2.332-6.152-2.332-8.484,0"
      "l-29.701,29.702"
      "l-29.701-29.702"
      "c-2.332-2.332-6.153-2.332-8.485,0"
      "l-12.726,12.727"
      "c-2.332,2.332-2.332,6.152,0,8.49"
      "l46.664,46.67"
      "c2.338,2.332,6.152,2.332,8.484,0"
      "l46.676-46.676"
      "C496.25,315.963,496.25,312.149,493.918,309.812";
  const CGRect kSVGBounds = CGRectMake(390.37, 295.399, 105.229, 99.268);

  // Transform so that the tip of the (downward pointing) chevron is at the
  // origin.
  const float s = std::max(kSVGBounds.size.width, kSVGBounds.size.height);
  CGAffineTransform t = CGAffineTransformMakeScale(size / s, size / s);
  t = CGAffineTransformTranslate(
      t, -CGRectGetMidX(kSVGBounds), -CGRectGetMaxY(kSVGBounds));

  SvgPathParser parser;
  return parser.ParsePath(kSVGPath, t);
}
